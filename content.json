{"meta":{"title":"Tiny熊的博客","subtitle":"记录我的学习与思考","description":"关注领域：个人成长、思考、总结、区块链，Linux，移动开发，Mac","author":"Tiny熊","url":"http://tinyxiong.com"},"pages":[{"title":"文章分类","date":"2017-12-09T12:54:53.000Z","updated":"2017-12-09T13:13:16.000Z","comments":false,"path":"categories/index.html","permalink":"http://tinyxiong.com/categories/index.html","excerpt":"","text":"哈哈哈哈"},{"title":"文章标签","date":"2017-12-09T12:46:05.000Z","updated":"2017-12-09T13:13:50.000Z","comments":false,"path":"tags/index.html","permalink":"http://tinyxiong.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PoW和PoS的大讨论 - by Jan","slug":"pow-or-pos","date":"2019-05-08T06:23:00.000Z","updated":"2019-05-08T06:20:35.645Z","comments":true,"path":"pow-or-pos/","link":"","permalink":"http://tinyxiong.com/pow-or-pos/","excerpt":"","text":"这两天在橙皮书的微信群里面产生了PoW和PoS的大讨论，甚是精彩，本文是Jan 的回复(节选)，非常精彩。 A: POS大户坐着获得的资本利得，是小散无法逾越的鸿沟，且无法约束他的权利。 B: 这个问题是社会正常现象吧,有钱的人挣钱本身就是比平民容易,他投入这么多钱收入却比别人少,那才是不公平啊,现在是大家获得的比例是一样的,大户投入的钱多,就是会获得更多的回报 这是一个PoW和PoS讨论中常见的对话。A提出了两个问题 (公平性问题) PoS大户坐着获利，普通人没有； (无法制约）PoS大户的权利无法约束。B回答了1。 对于问题1, 我同意B的看法。投入多回报多是合理的，无论是pow还是pos都是这样， 区块链是帮助实现过程公平而不是结果公平的工具。 在区块链里面我们依然会看到马太效应。试图用区块链去解决结果公平的后果是区块链治理的内涵无限扩大，将本该由协议解决的各种问题（后面会看到）统统推给投票去解决。然而无论是历史还是理论早就告诉我们，世界上并没有完美的群体选择制度。区块链是一个能够记录数据，保证数据不被篡改，为所有人提供数据的工具，通过这样一个工具帮助我们更好的实现过程公平，已经是非常非常大的进步了。 问题2是一个 在讨论中被忽略的关键问题。 投入资源换取回报天经地义，但前提是你想投入就能投入吗？举个例子，一个明星创业团队融资，是不是任何vc想投就能投进去呢？PoW具有非常好的开放性，使得后来的共识参与者总是可以加入共识群体，而PoS不具有这样的开放性。引用这里的讨论： 在PoS中，未来的共识群体是由今天的共识群体决定的。任何新的节点想要参与共识都需要通过至少一个交易来实现（e.g. 抵押，投票，etc.），而这个交易是否被处理是由今天的共识群体决定，他们可以处理这个交易，也可以不处理这个交易， 如果不处理这个交易，新的节点永远都无法参与共识 。同时，“不处理交易”是容易伪装而难于惩罚的行为，我还没有看到能在共识协议中解决这个问题的方案。PoS往往是根据stake的权重来分配出块比例（和节点数量没关系），考虑到大部分系统中stake的集中程度，这是一个非常实际的问题。 PoW是彻底的Permissionless。无论什么时候，只要你愿意，都可以买矿机和电力加入出块者的行列，不需要今天的矿工给你任何形式的许可。你也许会说，我还是需要购买矿机和电力呀，这是不是一种形式的许可呢？是的，从更低一层来说，这也是一种许可。但遗憾的是，在所有的Proof of XXX中，这已经是最去中心化的许可形式了，毕竟矿机生产和电力资源的去中心化程度远高于各种 tokens (的分散程度)。我们总是应该追求尽可能的去中心化，否则用回中心化系统就好了。 ”是否能够投入”本身可以看作一种option，有非常高的价值。PoW能有这样的性质，是因为工作量证明的计算是一种不依赖历史的计算， 无论你在任何时间点购买算力加入计算，你都和其他矿工在同一个起跑线上, 这是一个非常独特的、反直觉的性质，正是这个性质使得后来者总是能打破了早期参与者的优势。PoS不同，因为stake是系统中内生的资产，资产的所有权是由系统历史决定的，交易顺序是由系统历史决定的，因此无论是需要抵押token加入的pos，还是只需要持有token就可以参与的pos，其validator集合都是这个系统自身的历史决定，PoS和PoW在”参与共识是否需要依赖历史“上是截然不同的。我们很容易能看出，这是一个本质不同，无论什么样的上层设计都解决不了这一点。 因此PoW和PoS的设计，从根本上是两种不同的思路，体现两种不同的理念： (PoS) 系统应该让先发者获得天然的优势 (PoW) 系统不应该让先发者获得天然的优势 注意主语是“系统”，共识参与者在系统外的优势不是任何协议设计可以解决的。 A: pos买币staking不就是投入了吗 确实是投入，但是这里的“投入获得回报”中的”回报”已经变了。对于投入获得的回报我们需要分开来看，一种回报是token收益，最近的pos基本都支持delegate, 所以基本上所有人都有这个option. 另一种是参与共识的权利，根据上面的回答，它可以被现有的validator垄断，大部分人没有option。权利有很多种，分红只是其中一种，而且不是关键的那一种。 那么共识的权利为什么重要，它有什么用呢？它意味着你可以对交易排序，而交易排序决定了链上众筹时你的交易能不能及时上链，在DEX里面交易时你的订单能不能及时成交，等等等等。在PoS的系统上做DeFi？你需要认真考虑一下validator本身是做什么的，是否和你的发送的交易有利益相关？我们知道，DeFi的交易很可能是价值含量非常高的交易，e.g. DEX里面一个巨大的买单，这时候validator如果安排一个插队的交易怎么办？仅仅是交易顺序的不同就可以造成巨大的获利，何况共识节点能做的远大于此？操控交易排序是无法被发现的 聪明的你一定会想到：“那PoW的矿工/矿池不是一样有这样的问题吗？” 没错，PoW的矿工一样有这样的权利，但PoW有两个优点可以削弱这个问题： 出块节点和生态中的关键用户是解耦的。生态中的关键用户，指的是交易所、钱包等围绕区块链提供服务的服务商，它们为大量的用户提供优质的服务，聚集了大量的用户和交易。在PoS中，由于拥有大量用户和交易，stake会自然的往生态中的关键用户集中，形成天然的stake pool，因此关键用户在业务上的优势可以转化成在共识和治理上的优势（在某些链里面已经体现的非常明显了），使得先行者的优势更加强化。在PoW中，矿工群体和交易所/钱包是独立的，他们有不同的专业分工，通过不同的专业知识，不同的方式获取回报，关键用户不能将自己的业务优势转化为协议中的优势，矿工也没办法将自己在协议中的优势转化为上层业务的优势。在PoW中，开发者、用户和共识节点之间可以形成制衡。 PoW的共识是开放的（见上文），充满了激烈的竞争。也许一个矿池/矿工可以在短时间内做到这一点，但由于新的矿工总是可以自由加入，想要长久的做到这一点是非常困难的，激烈竞争将会造就一个越来越公平的充分竞争的市场，这需要时间(30年？maybe)。反过来，在PoS中，由于天然的先行者的优势，以及业务优势和共识优势的绑定，先行者的优势只会越来越大，竞争将逐渐消失，最后形成垄断或寡头。在基础设施级的协议里面，我们应该尽可能的去避免垄断。 区块链本身是一个大的排队机，决定排序的权利是这个系统中最关键的权利。 在PoS中，validator集合中的validator数目是无关紧要的，并不能代表stake分散。如果你有99%的stake，你应该把它们分散到100个甚至1000个validator上去。 PoW中同样会有算力集中在大矿工手中的问题，但是由于PoW的开放性以及系统没有给后来者制造劣势（见上文），这样的集中只会是暂时的，算力将在激烈的竞争中不停的从一个人手中转移到另一个人手中。PoW赞美竞争，PoW是一个开放的系统，只有开放的系统才可能远离热力学的终局 1，保持长久的生机。 PoS有其价值，也有其问题，因此无法适用所有场景。Layer 1的区块链协议必须使用PoW，只有使用PoW的Layer 1才能解决我们希望解决的问题，实现我们希望的未来。 来源：https://talk.nervos.org/t/pow-vs-pos/1732?u=janx","categories":[{"name":"学习","slug":"学习","permalink":"http://tinyxiong.com/categories/学习/"}],"tags":[{"name":"共识讨论","slug":"共识讨论","permalink":"http://tinyxiong.com/tags/共识讨论/"}]},{"title":"【转】10个JavaScript开发者必须知晓的概念","slug":"javascript-level","date":"2019-05-04T15:53:00.000Z","updated":"2019-05-04T15:26:51.752Z","comments":true,"path":"javascript-level/","link":"","permalink":"http://tinyxiong.com/javascript-level/","excerpt":"","text":"立即执行函数立即执行函数，即Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作： 1234(function() &#123; // 代码 // ...&#125;)(); function(){…}是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。立即执行函数也可以理解为立即调用一个匿名函数。立即执行函数最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。 闭包对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。 123456789101112131415161718function f1()&#123; var N = 0; // N是f1函数的局部变量 function f2() // f2是f1函数的内部函数，是闭包 &#123; N += 1; // 内部函数f2中使用了外部函数f1中的变量N console.log(N); &#125; return f2;&#125;var result = f1();result(); // 输出1result(); // 输出2result(); // 输出3 代码中，外部函数f1只执行了一次，变量N设为0，并将内部函数f2赋值给了变量result。由于外部函数f1已经执行完毕，其内部变量N应该在内存中被清除，然而事实并不是这样：我们每次调用result的时候，发现变量N一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！ 使用闭包定义私有变量通常，JavaScript开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量： 123456789101112131415161718function Product() &#123; var name; this.setName = function(value) &#123; name = value; &#125;; this.getName = function() &#123; return name; &#125;;&#125;var p = new Product();p.setName(\"Fundebug\");console.log(p.name); // 输出undefinedconsole.log(p.getName()); // 输出Fundebug 代码中，对象p的的name属性为私有属性，使用p.name不能直接访问。 prototype每个JavaScript构造函数都有一个prototype属性，用于设置所有实例对象需要共享的属性和方法。prototype属性不能列举。JavaScript仅支持通过prototype属性进行继承属性和方法。 12345678910111213141516171819function Rectangle(x, y)&#123; this._length = x; this._breadth = y;&#125;Rectangle.prototype.getDimensions = function()&#123; return &#123; length: this._length, breadth: this._breadth &#125;;&#125;;var x = new Rectangle(3, 4);var y = new Rectangle(4, 3);console.log(x.getDimensions()); // &#123; length: 3, breadth: 4 &#125;console.log(y.getDimensions()); // &#123; length: 4, breadth: 3 &#125; 代码中，x和y都是构造函数Rectangle创建的对象实例，它们通过prototype继承了getDimensions方法。 模块化JavaScript并非模块化编程语言，至少ES6落地之前都不是。然而对于一个复杂的Web应用，模块化编程是一个最基本的要求。这时，可以使用立即执行函数来实现模块化，正如很多JS库比如jQuery以及我们Fundebug都是这样实现的。 12345678910111213141516171819202122var module = (function() &#123; var N = 5; function print(x) &#123; console.log(\"The result is: \" + x); &#125; function add(a) &#123; var x = a + N; print(x); &#125; return &#123; description: \"This is description\", add: add &#125;;&#125;)();console.log(module.description); // 输出\"this is description\" module.add(5); // 输出“The result is: 10” 所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，module为一个独立的模块，N为其私有属性，print为其私有方法，decription为其公有属性，add为其共有方法。 变量提升JavaScript会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的变量提升(Hoisting)。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。 但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错： 123console.log(y); // 输出undefinedy = 2; // 初始化y 上面的代码等价于下面的代码： 12345var y; // 声明yconsole.log(y); // 输出undefinedy = 2; // 初始化y 为了避免BUG，开发者应该在每个作用域开始时声明变量和函数。 柯里化柯里化，即Currying，可以是函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。 12345678910111213var add = function(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;;console.log(add(1)(1)); // 输出2var add1 = add(1);console.log(add1(1)); // 输出2var add10 = add(10);console.log(add10(1)); // 输出11 代码中，我们可以一次性传入2个1作为参数add(1)(1)，也可以传入1个参数之后获取add1与add10函数，这样使用起来非常灵活。 apply, call与bind方法JavaScript开发者有必要理解apply、call与bind方法的不同点。它们的共同点是第一个参数都是this，即函数运行时依赖的上下文。 三者之中，call方法是最简单的，它等价于指定this值调用函数： 1234567891011121314var user = &#123; name: \"Rahul Mhatre\", whatIsYourName: function() &#123; console.log(this.name); &#125;&#125;;user.whatIsYourName(); // 输出\"Rahul Mhatre\",var user2 = &#123; name: \"Neha Sampat\"&#125;;user.whatIsYourName.call(user2); // 输出\"Neha Sampat\" apply方法与call方法类似。两者唯一的不同点在于，apply方法使用数组指定参数，而call方法每个参数单独需要指定： apply(thisArg, [argsArray]) call(thisArg, arg1, arg2, …) 12345678910111213var user = &#123; greet: \"Hello!\", greetUser: function(userName) &#123; console.log(this.greet + \" \" + userName); &#125;&#125;;var greet1 = &#123; greet: \"Hola\"&#125;;user.greetUser.call(greet1, \"Rahul\"); // 输出\"Hola Rahul\"user.greetUser.apply(greet1, [\"Rahul\"]); // 输出\"Hola Rahul\" 使用bind方法，可以为函数绑定this值，然后作为一个新的函数返回： 123456789101112var user = &#123; greet: \"Hello!\", greetUser: function(userName) &#123; console.log(this.greet + \" \" + userName); &#125;&#125;;var greetHola = user.greetUser.bind(&#123;greet: \"Hola\"&#125;);var greetBonjour = user.greetUser.bind(&#123;greet: \"Bonjour\"&#125;);greetHola(\"Rahul\") // 输出\"Hola Rahul\"greetBonjour(\"Rahul\") // 输出\"Bonjour Rahul\" MemoizationMemoization用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。 123456789101112131415161718192021222324252627function memoizeFunction(func)&#123; var cache = &#123;&#125;; return function() &#123; var key = arguments[0]; if (cache[key]) &#123; return cache[key]; &#125; else &#123; var val = func.apply(this, arguments); cache[key] = val; return val; &#125; &#125;;&#125;var fibonacci = memoizeFunction(function(n)&#123; return (n === 0 || n === 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);&#125;);console.log(fibonacci(100)); // 输出354224848179262000000console.log(fibonacci(100)); // 输出354224848179262000000 代码中，第2次计算fibonacci(100)则只需要在内存中直接读取结果。 函数重载所谓函数重载(method overloading)，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，函数重载可以通过if…else或者switch实现，这就不去管它了。jQuery之父John Resig提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。 从效果上来说，people对象的find方法允许3种不同的输入: 0个参数时，返回所有人名；1个参数时，根据firstName查找人名并返回；2个参数时，根据完整的名称查找人名并返回。 难点在于，people.find只能绑定一个函数，那它为何可以处理3种不同的输入呢？它不可能同时绑定3个函数find0,find1与find2啊！这里的关键在于old属性。 由addMethod函数的调用顺序可知，people.find最终绑定的是find2函数。然而，在绑定find2时，old为find1；同理，绑定find1时，old为find0。3个函数find0,find1与find2就这样通过闭包链接起来了。 根据addMethod的逻辑，当f.length与arguments.length不匹配时，就会去调用old，直到匹配为止。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function addMethod(object, name, f)&#123; var old = object[name]; object[name] = function() &#123; // f.length为函数定义时的参数个数 // arguments.length为函数调用时的参数个数 if (f.length === arguments.length) &#123; return f.apply(this, arguments); &#125; else if (typeof old === \"function\") &#123; return old.apply(this, arguments); &#125; &#125;;&#125;// 不传参数时，返回所有namefunction find0()&#123; return this.names;&#125;// 传一个参数时，返回firstName匹配的namefunction find1(firstName)&#123; var result = []; for (var i = 0; i this.names.length; i++) &#123; if (this.names[i].indexOf(firstName) === 0) &#123; result.push(this.names[i]); &#125; &#125; return result;&#125;// 传两个参数时，返回firstName和lastName都匹配的namefunction find2(firstName, lastName)&#123; var result = []; for (var i = 0; i this.names.length; i++) &#123; if (this.names[i] === (firstName + \" \" + lastName)) &#123; result.push(this.names[i]); &#125; &#125; return result;&#125;var people = &#123; names: [\"Dean Edwards\", \"Alex Russell\", \"Dean Tom\"]&#125;;addMethod(people, \"find\", find0);addMethod(people, \"find\", find1);addMethod(people, \"find\", find2);console.log(people.find()); // 输出[\"Dean Edwards\", \"Alex Russell\", \"Dean Tom\"]console.log(people.find(\"Dean\")); // 输出[\"Dean Edwards\", \"Dean Tom\"]console.log(people.find(\"Dean\", \"Edwards\")); // 输出[\"Dean Edwards\"] 参考链接 闭包 - MDN JavaScript闭包-块级作用域和私有变量 Javascript继承机制的设计思想 - 阮一峰 变量提升 - MDN JS函数式编程指南 浅谈JavaScript函数重载 本文链接地址：https://blog.fundebug.com/2017/07/17/10-javascript-difficulties/","categories":[{"name":"学习","slug":"学习","permalink":"http://tinyxiong.com/categories/学习/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://tinyxiong.com/tags/JavaScript/"}]},{"title":"理解 EIP712","slug":"eip712","date":"2019-04-25T15:53:00.000Z","updated":"2019-04-25T03:23:18.380Z","comments":true,"path":"eip712/","link":"","permalink":"http://tinyxiong.com/eip712/","excerpt":"","text":"这个EIP 是为了提高链下消息签名对链上的可用性。因为节省gas以及减少链上交易的原因，采用链下消息签名的需求越来越多。 我们知道对数据签名后，它会变成一段无法阅读的字节字符串，而有时候，我们需要知道背后所代码数据的含义，下面这个图很好表达了这个对比： 图片来源于eip-712 讨论 为了签名结构化数据，EIP712 中加入了新的远程调用用法： eth_signTypedData， web3.js 也有对应的实现：web3.eth.signTypedData。 如何结构化数据可以参考eip-712 标准，这里也有一篇文章介绍：理解 EIP712 - 类型结构化数据 Hash 与签名","categories":[{"name":"学习","slug":"学习","permalink":"http://tinyxiong.com/categories/学习/"}],"tags":[{"name":"EIP712","slug":"EIP712","permalink":"http://tinyxiong.com/tags/EIP712/"}]},{"title":"SEO 经验总结","slug":"seo","date":"2019-04-12T15:53:00.000Z","updated":"2019-04-14T09:17:11.425Z","comments":true,"path":"seo/","link":"","permalink":"http://tinyxiong.com/seo/","excerpt":"搜索引擎能链接到内容不代表会收录收录不代表有好的排名，必须要努力提升网站权重。 因为做深入浅出区块链 - 技术博客的缘故，想有更好的搜索引擎收录，读了《SEO实战密码》，做一个笔记整理。","text":"搜索引擎能链接到内容不代表会收录收录不代表有好的排名，必须要努力提升网站权重。 因为做深入浅出区块链 - 技术博客的缘故，想有更好的搜索引擎收录，读了《SEO实战密码》，做一个笔记整理。 搜索引擎怎么收录内容搜索引擎能收录的内容是有限的，内容是否能收录主要看页面的内容是否足够好（权重和原创性）并一定首发就是原创性， 关键是看谁先收录，权重低的页面即使首发也得不到收录，所以晚发在其他平台的内容反而可能被认为是原创。 判断原创还有一点： 哪一个内容被引用的次数多， 越多越被认为原创（后面外链建设再说明）。 所以注意内容重复，内容是否要发到高权重平台， 发的话一定要在开头表明：首发于何处，原文链接是什么。 提高收录主要是两点： 内容建设 外链建设 这两点都需要时间的积累， 域名时间长也是一个很大的优势。 内容建设内容是基础，特别是原创内容，关于内容要了解： 网站内容越多，权重也越大， 所以得综合考虑使用子域名和子目录来分配内容。 内容更新越频繁，蜘蛛（爬虫）来的也会快。 生产内容时，注意文章标题、锚文本、图片Alt文字是否对SEO友好，同时要多关注长尾词。 有一些内容建设注意要点： 避免内部竞争， 复制的内容会分散权重，导致都得不到好的排名； 注意权重浪费，降低非必要页面的权重， 如关于页面等，因为一个网站能被收录的内容是有上限的； 网站结构上考虑权重分配，原则离首页的距离越远（点击越多），权重越小，注意翻页设计； 内容是有时效性的， 刚发布的内容权重最高， 随着时间的推移， 权重会降低，更新内容可提高权重； 内容要尽量对本站关联主题内容有所引用，对已有内容做信任背书。 外链建设搜索引擎如何知道一个内容的好坏： 要明白外部链接的重要性超过内容本身。 就像发表论文被引用一样，引用越多说明论文质量越好。搜索引擎也很傻，他不懂专业知识分辨内容质量。 一个内容的反向链接（外链）越多，搜索引擎给的权重会越大，更要认识到一点：外链的质量比数量重要。大量无关主题无关的引用没有效果，可能还被认为作弊（主题相关性很重要）。像论坛、博客留言也会认为是低质量外链。 关于外链需要知道的两个原则： 信任指数衰减: 链接每传递一层，权重就会下降一个百分比，同时权重高的页面传递出来的权重越大。 比起朋友的朋友，我们会更信任朋友，就是信任衰减。 信任与数量成反比: 如果一个页面只有1个外链，它传递的信任权重是10个外链的10倍。 深入浅出区块链 的置顶文章区块链技术学习指引 如果从一篇外链建设贴来说就不好，因为链接太多了。 这两个原则很关键，指导着我们建设外链： 要尽量找权重高的站点建设外链 发外链贴的时候，也要重视质量，不可堆积链接。 虽说外链是用来吸引蜘蛛的，但是如果发的外链，人不愿意看的话， 那蜘蛛也不会喜欢。 一些操作上的注意点： 大部分网站都在链接上加了nofollow(告诉浏览器不要跟踪和不传递信任权重) 尝试不同的锚文字去发外链； 掌握推文篇幅和链接比例； 友情链接也外链，尽量找高权重 如果得不到收录，也需要主动向百度、google 提交链接（虽然也不一定收录） 避免原文直接复制发帖，应该加上对原文的引用，多加几个锚文本，必要时对内容进行精简。 多尝试不同的角度、新闻事件做引用推荐。","categories":[{"name":"学习","slug":"学习","permalink":"http://tinyxiong.com/categories/学习/"}],"tags":[{"name":"SEO","slug":"SEO","permalink":"http://tinyxiong.com/tags/SEO/"}]},{"title":"畅想去中心化社会","slug":"de-social","date":"2019-04-02T15:53:00.000Z","updated":"2019-04-12T13:45:34.037Z","comments":true,"path":"de-social/","link":"","permalink":"http://tinyxiong.com/de-social/","excerpt":"","text":"畅想去中心化社会畅想一下未来的去中心化社会，政府广泛使用去中心化技术提供服务，政府成为一个自动运行的社会系统，每人都将拥有一个身份id（在去中心化网络上），我们的身份特征（如指纹，面部识别）就是私钥。 出门就再也不用带身份证，毕业证自动签发关联到身份id；办护照只需要向相应的智能合约提交申请；办结婚证只需要两个人在婚姻智能合约上签个名； 不再需要监督、审查人员，杜绝腐败，大大提高效率。 并且这些信息还可以跨链授权，比如以太坊可跨链访问到政府链上的应用信息，我们在借Dai 就有更高的限额。 （政府只是去中心化网络的维护者，就像公链的项目方，规则的制定者，财产和数据依旧属于我们自己） 其实一切正在悄然发生~","categories":[{"name":"思考","slug":"思考","permalink":"http://tinyxiong.com/categories/思考/"}],"tags":[{"name":"社会","slug":"社会","permalink":"http://tinyxiong.com/tags/社会/"}]},{"title":"再聊聊跨链","slug":"cross_chain","date":"2019-03-28T15:53:00.000Z","updated":"2019-03-29T14:20:33.651Z","comments":true,"path":"cross_chain/","link":"","permalink":"http://tinyxiong.com/cross_chain/","excerpt":"","text":"再聊聊跨链：Polkadot和Cosmos 两个跨链的头部项目，他们都认为自己是下一代的互联网，他们构建的像今天TCP/IP协议一样的协议。 虽然我很关注这两个项目， 不过也引发我的思考， 我们是否会那么需要跨链。如果把链比作一座山，跨链就是在山和山之间修桥， 跨链的前提是已经有很多的山了， 在这个山的人想去另一座山。 与跨链不同，侧链可以认为是修建索道。跨链 侧链看起来是类似的事情，他们的思路却完全不同， 在跨链中，跨链本身的链是主干，所接入的链都是分支， 而侧链自己是旁支，他需要接入一个主干。 在跨链看来未来可能有一两座大大的山，山里已经有完整的生态，可以自由的玩耍，串门只要有索道就可以。 短期来看，侧链较容易落地，不过区块链本身还在早期，未来是怎样，我们先交给时间。","categories":[{"name":"思考","slug":"思考","permalink":"http://tinyxiong.com/categories/思考/"}],"tags":[{"name":"跨链","slug":"跨链","permalink":"http://tinyxiong.com/tags/跨链/"}]},{"title":"未来网络Web3技术栈","slug":"web3","date":"2019-03-28T15:53:00.000Z","updated":"2019-03-29T15:04:18.574Z","comments":true,"path":"web3/","link":"","permalink":"http://tinyxiong.com/web3/","excerpt":"","text":"web3 是在互联网世界之上再造一层世界 web3的第0层， 是p2p网络消息，和基本虚拟机层web3的第1层，去中心后数据通信，存储，货币协议web3的第2层是链下拓展协议","categories":[{"name":"学习","slug":"学习","permalink":"http://tinyxiong.com/categories/学习/"}],"tags":[{"name":"Web3","slug":"Web3","permalink":"http://tinyxiong.com/tags/Web3/"}]},{"title":"预言机的思考","slug":"oracle","date":"2019-03-28T15:53:00.000Z","updated":"2019-03-29T14:21:31.126Z","comments":true,"path":"oracle/","link":"","permalink":"http://tinyxiong.com/oracle/","excerpt":"","text":"我们知道所有的数据在经过节点的验证之后，才能上链。而节点验证达成共识的一个条件是：验证时数据输入是相同的。这让区块链上只能使用链内的确定性的数据，因为链外的数据没法保证在不同的时间进行验证时数据的一致性。 这让区块链和我们的现实世界产生了割裂。 预言机就是这样一座桥（怎么总是喜欢用桥来比喻？），联通着区块链和现实世界。 如果区块链（智能合约）想要基于某个外部状态做些事情（比如Dai项目依靠外部的币价信息），它不能主动去拿外部数据，而是要依靠预言机把外部数据以交易的形式发送进来，从而把一个不确定的数据转化为一个确定的输入。 好了，问题来了，我们说区块链创造了信任，就是因为去中介，现在又引入一个预言机中介，好像是一个讽刺，如何来保证预言机没有作恶呢（加入外部数据是真实的，指如何确保预言机不会篡改外部数据）？ 这也是为什么说区块链还在早期，成熟的预言机机制会极大的促进区块链的发展，不少团队正在探索去中心化预言机，未来值得期待。","categories":[{"name":"思考","slug":"思考","permalink":"http://tinyxiong.com/categories/思考/"}],"tags":[{"name":"预言机","slug":"预言机","permalink":"http://tinyxiong.com/tags/预言机/"}]},{"title":"思考：一个人在情况下成长最快？","slug":"stay-hungery","date":"2019-03-23T15:53:00.000Z","updated":"2019-03-29T14:20:43.528Z","comments":true,"path":"stay-hungery/","link":"","permalink":"http://tinyxiong.com/stay-hungery/","excerpt":"","text":"大家思考下 一个人在情况下成长最快呢？ 是当一个人保持空杯心态、好奇心态时 很多时候是我们的自满自以为是，阻碍了我们学习进步。 我以前对EOS有一些偏见，认为EOS太多中心化，让我错失很多几乎去学习了解它，也让登链学院错过一些机会。 登链学院 是我创办的一家区块链培训教育机构 我也经常给一些朋友、同事、学员一些学习建议学习某项技术，经常遇到对方回答如：这项技术过时了、没前途等等。 当我们对一个事物一上来就用一个筛子过滤一下（用自己以为的经验进行判断），我们会错失很多。 任正非的”先僵化，后优化，再固化“， 僵化对比我们好的技术照搬全抄，对的错的一起抄，在理解吸收之后在优化。 如果我们一开始就对事物加以判断以做区分，意味着我们失去理解他的机会。 与各位共勉。 思考思考、在思考，我们是否保持了足够的空杯心态 听前老板傅盛课程有感","categories":[{"name":"思考","slug":"思考","permalink":"http://tinyxiong.com/categories/思考/"}],"tags":[{"name":"成长","slug":"成长","permalink":"http://tinyxiong.com/tags/成长/"}]},{"title":"学习跨链","slug":"sidechain","date":"2019-03-22T15:00:10.000Z","updated":"2019-03-29T14:21:47.815Z","comments":true,"path":"sidechain/","link":"","permalink":"http://tinyxiong.com/sidechain/","excerpt":"","text":"利用中介 跨链如何把你手里 的1 BTC 换成 25 ETH， 对于你来说就是把 比特币的资产转移到了 以太坊，最简单直接的方法就是 找一个中介，他收到了 1 BTC 之后转给你 25 ETH，这就完成了跨链。 哈哈，简单粗暴，很熟悉吧，交易所就是干这个事，缺点很明显，就是中心化。 这种方式有一个词，叫： 公证人机制（Notary schemes）或见证人机制，是不是一下子高大上了。 其实 Ripple 就是用类似这种方式来跨链的。 哈希时间锁定（Hash-locking） 利用中介很容易发生一个问题， 中介收到我们的BTC后就跑路了， 不给我们打ETH。 哈希时间锁定（HTLC）最早出现在比特币的闪电网络，支持跨链资产进行原子交换。 它用到了两把锁：哈希锁和时间锁。迫使资产的接收方在期限内确定收款并产生一种收款证明给付款方，否则资产会归还给付款方。 用一个例子来阐述如何使用哈希时间锁定进行跨链的原子资产交换，假设Alice和Bob有资产交换的需求，Alice想用1个BTC和Bob换20个ETH. 那么首先需要在两条链上设置哈希时间锁定合约，然后执行如下步骤： Alice 随机构建一个字符串s，并计算出其哈希 h = hash(s)； Alice 将h发送给Bob的合约； Alice锁定自己的1个BTC资产，并设置一个较长的锁定时间t1, 并设置了获取该BTC的一个条件：谁能够提供h的原始值s就可以得到该BTC; Bob观察到Alice 合约中锁定了一个BTC, 然后Bob锁定自己的20个ETH资产，并设置一个相对较短的锁定时间t2, t2 &lt; t1, Bob也设置了同样获取条件（谁提供h的原始值s就可以获取20个ETH）； Alice将自己最初生成的字符串s 发送到Bob的合约里取得了20个ETH; Bob观察到步骤5中Alice的s值，将其发送给Alice的合约成功获取1个BTC; 至此Alice和Bob完成了资产的交换。 哈希时间锁定合约也有一些约束条件： 时间设置需要有时间差， 只适合偏资产或者关键数据的交换，在支付领域较多，例如闪电网络、雷电网络以及跨链资产转移协议Interledger等。 明天在介绍 侧链/中继链 侧链/中继链（Sidechains / Relays）侧链是指完全拥有某链的功能的另一条区块链，侧链可以读取和验证主链上的信息。主链不知道侧链的存在，由侧链主动感知主链信息并进行相应的动作。而中继链则是侧链和公证人机制的结合体，中继链具有访问需要和验证进行互操作的链的关键信息并对两条链的跨链消息进行转移。从这个角度看中继链也是一种去中心的公证人机制。 https://tech.hyperchain.cn/blockchain-interoperability/?from=timeline","categories":[{"name":"学习","slug":"学习","permalink":"http://tinyxiong.com/categories/学习/"}],"tags":[{"name":"侧链","slug":"侧链","permalink":"http://tinyxiong.com/tags/侧链/"}]},{"title":"Cosmos & Tendermint","slug":"cosmos_tendermint","date":"2019-03-15T14:59:27.000Z","updated":"2019-03-21T15:21:10.197Z","comments":true,"path":"cosmos_tendermint/","link":"","permalink":"http://tinyxiong.com/cosmos_tendermint/","excerpt":"","text":"Cosmos 和 Polkadot 的设计有很多相似之处，还有国内团队AckBlock的Forge，今天好好看了看Cosmos cosmos &amp; tendermintCosmos的人认为： 很多人（组织）会想拥有一条属于自己的链，通过 tendermint通用的区块链开发框架，快速定制开发自己的链。 一条链包括3个部分的话：网络层，共识层，应用层。 tendermint 包含两部分： tendermint core 把共识层和网络层封装在了一起，共识层是拜占庭共识算法+pos。 ABCI协议，Application Blockchain Interface， tendermint core 引擎和上面开发者自定义的应用层之间的接口。 Cosmos SDK 是实现ABCI协议，如 区块链中的一些通用模块标准化，这些通用模块覆盖了大部分应用层需要具备的功能，比如：staking（抵押机制）、slashing（惩罚机制）、IBC（跨链功能），账户accounts、治理、奖励&amp;手续费等。 跨链 有很多条链的时候，跨链问题就来了， comos 抽象出来一个 机制抽象 IBC协议，Inter-Blockchain Communication。IBC就像一座桥，让不同的链可以互相连通（支持简单的价值传递）。 有了IBC这个跨链通信协议，我们如何构造一个互联互通的区块链网络？ 两两相连 单连跨链验证 cosmos采用另一种办法跨链。他们采用一种模块化的架构来建立整个区块链网络的连接，这个架构包括两个组成部分：一个叫hub，一个叫zone。 后续进一步讲究 参考Cosmos上线主网了，但是“为什么需要跨链”依然有待探寻","categories":[{"name":"学习","slug":"学习","permalink":"http://tinyxiong.com/categories/学习/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://tinyxiong.com/tags/学习/"}]},{"title":"Uniswap 学习记录","slug":"learn_uniswap","date":"2019-03-15T14:59:27.000Z","updated":"2019-03-21T15:16:39.576Z","comments":true,"path":"learn_uniswap/","link":"","permalink":"http://tinyxiong.com/learn_uniswap/","excerpt":"","text":"Uniswap 协议 定义Uniswap 是一个以太坊上运行的去中心化交易所协议，能让 ETH 和 ERC20 代币之间的兑换变得非常简易。 机制Uniswap 用一个被称为“自动做市商”（AMM）的模型，根据可用的流动性自动调整兑换比率。 Uniswap 使用了一个由 Vitalik 提出的“恒定乘积做市商”的模型，能让在合约中锁定的两种资产之间进行交易。 “恒定乘积做市商”使用一个非常简单的公式 x*y=k，其中 x 是 ETH，y 是 ERC20 代币，k 是恒量。 如果你将所有的 ETH 卖给 Uniswap 合约，仍还有很少量的 ERC20 代币可供购买。例如，如果有人向合约出售了1个 ETH，现在总共有11个 ETH。为了保持 k 恒定，就需要有 500/11 = 45.45 个 ERC20 代币。所以你要给发送 50 - 45.45 = 4.55 个 ERC20 代币给买家。 成为流动性提供者时，同时存入 ETH 和 ERC20 代币，流动性提供者可以得到交易分成。 Uniswap和 Bancor 的区别Uniswap和 Bancor 的区别： 其他目前 Uniswap 流动性池中有2万个ETH， Uniswap代币兑换是及时的。Uniswap合约使用Vyper开发，所有内容只有创始人（Hayden）一个全职开发者。 参考https://mp.weixin.qq.com/s/15UWTVRHVLU3DCyR48zh_w","categories":[{"name":"学习","slug":"学习","permalink":"http://tinyxiong.com/categories/学习/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://tinyxiong.com/tags/学习/"}]},{"title":"重新启用网站，记录每日思考","slug":"new-start-day1","date":"2019-03-10T06:20:28.000Z","updated":"2019-03-21T15:21:34.473Z","comments":true,"path":"new-start-day1/","link":"","permalink":"http://tinyxiong.com/new-start-day1/","excerpt":"","text":"昨天我加入了一个每日阅读特训营，强迫自己每日阅读进行总结，其实每日阅读一直都有，不过总结做的少，这是一个go开发者组织的活动， 也强迫自己学习下Go。 今日学习： 关于学习 陈浩在ARTS 打卡读者群召集令，写到： 学习没有捷径、是逆人性的，需要长期付出实际行动和精力。听别人讲、看别人的书，远不如自己思辨、践行、总结和归纳。 过去两年自己也是在写技术博客，加上创业做教育培训， 自己深入体会。","categories":[{"name":"思考","slug":"思考","permalink":"http://tinyxiong.com/categories/思考/"}],"tags":[{"name":"思考","slug":"思考","permalink":"http://tinyxiong.com/tags/思考/"}]},{"title":"一招解决无法连接github问题","slug":"fix_connect_github","date":"2018-03-16T08:36:36.000Z","updated":"2018-03-18T15:23:48.770Z","comments":true,"path":"fix_connect_github/","link":"","permalink":"http://tinyxiong.com/fix_connect_github/","excerpt":"因为大家都知道的原因，有时github没法连接上，本文给大家一个解决办法。","text":"因为大家都知道的原因，有时github没法连接上，本文给大家一个解决办法。 估计今天很多同学遇到了阿里云无法连github的问题。想必遇到这个问题的你一定很恼火，过来看看吧，本文很短，但很实用。 前提备一台香港服务器（可访问github的服务器都行） 设置Socks 代理1$ ssh -D 1080 hk_ip 这条命令在无法连接github的主机上执行。hk_ip 为hk服务器ip 给github 配置代理在无法连接github的主机上，打开.ssh/config, 添加一下记录12Host github.com ProxyCommand=nc -X 5 -x localhost:1080 %h %p 好了， 执行下git pull 试试看，已经可以成功访问github了。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://tinyxiong.com/categories/Linux/"},{"name":"github","slug":"Linux/github","permalink":"http://tinyxiong.com/categories/Linux/github/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://tinyxiong.com/tags/Linux/"},{"name":"ssh","slug":"ssh","permalink":"http://tinyxiong.com/tags/ssh/"}]},{"title":"程序员如何提高工作效率","slug":"about-effciency","date":"2017-12-14T13:10:47.000Z","updated":"2017-12-14T14:57:30.000Z","comments":true,"path":"about-effciency/","link":"","permalink":"http://tinyxiong.com/about-effciency/","excerpt":"很多人问我，你怎么效率那么高，工作很忙，又要带娃，还写博客，还有时间运动。今天就写写这个话题：程序员如何提高工作效率","text":"很多人问我，你怎么效率那么高，工作很忙，又要带娃，还写博客，还有时间运动。今天就写写这个话题：程序员如何提高工作效率 保持高工作效率，我觉得主要有一下4个方面，希望能对大家有帮助。 集中目标工作列表不论是开发还是设计，还是其他职业，工作列表都很重要，工作目标很明确。工作的时候才能格外专注，才不会走神。用自己最熟悉的工具（我用Evernote），把待办工作列表（今天要做什么）记录下来，很重要的一点是记录分解后的小目标（分解任务也是一个很重要的能力）。同时也保持工作中产生的新的问题（任务），经常性地调整当前工作任务列表，根据重要性对这些任务进行划分，经常想着那些最重要的问题。 专注目标专注目标不是那么容易做到的，需要学会分离与当前无关的任务/问题，工作中经常会碰到的问题可以首先寻找简单可用可靠的方案，并将心中的疑虑记录下来，集中成一个列表，工作之外翻翻书，系统思考和学习，而不会因为这个问题而叉开思路对相关的内容研究一番。总之，专注当前的任务，把新问题记录下来，回头再专心攻克。学会避繁就简，在基本功的增强后，会发现很多问题可以简单阅读或查找文档，或浏览问题相关的库的源码解决； 学会简化问题无论是在广义的工作方法/工作态度上，还是在针对具体问题上，很重要的一个个人能力就是化繁为简了。化繁为简是所有工作方法/软件设计的核心。将那些可以砍掉的工作砍掉，做到尽可能地简单。 从工作方法和态度上来讲，真正需要去做的工作才值得去做，大力砍掉那些不应该在当前工作中处理的事情。例如不必要的优化，不必要的扩展性，不必要的性能，不必要的功能，可以不要的技术，不必要的流程，不必要的文档，统统砍掉，一切可以没有的全都不能有。 工作中也可能遇到非关键的难题，通常绕过它们，使用更简单的方案就是了。纠缠于这些不重要的难题，最容易浪费时间。 从设计/实现来讲，最好的方案就是最简单直接、一眼就能看懂的方案。而且通常最简单直接的方式，通常性能也最好。 基本功基本功的内容十分复杂。第一项基本功是对整个计算机体系的理解，对操作系统/虚拟机/数据库本质的理解，对语言基础类和库的理解，这些是核心基本功。第二项基本功是学习能力。 通过快速阅读核心文档理解核心思想，然后其他的东西总是能从文档中查到就行。细枝末节的东西，即学即用，学过就忘可也。第三项基本功是文档、代码、资料的搜索和收集，技术问题建议大家用Google搜索，有意识的整理出自己的代码库。 工具选择工具核心标准，就是简单朴素可信赖，如果一个工具出几次诡异现象，那就干脆丢掉它。熟悉工具，实际上我们工作中，就是和各种各样工具打交道，各种IDE，编辑器，版本管理工具，命令行终端，TODO工具等等。要想在工作中如行云流水，一定要熟悉工具，包括工具快捷键，命令，原理等等。写自己工具，很多时候，我们需要重复的做一件事情，当你做第2遍，第3遍的时候，就应该想一想，能不能自动化，很多简单的几句shell就可以搞定，麻烦的一点的，可以先记录下来。比如，我就写了非常多的脚本：一个命令反编译APK并查看源码、提取当前版本号打git tag并提交等等。很多时候几分钟到几十分钟的事情可以压缩到几秒钟完成，也避免了对工作的打断。 前3点靠大家各自的修行，第4点工具部分，我会在博客中进一步分享。 原始链接:http://tinyxiong.com/about-effciency/关于作者：Tiny熊：深入浅出区块链博主","categories":[{"name":"心得","slug":"心得","permalink":"http://tinyxiong.com/categories/心得/"}],"tags":[{"name":"心得","slug":"心得","permalink":"http://tinyxiong.com/tags/心得/"},{"name":"工作效率","slug":"工作效率","permalink":"http://tinyxiong.com/tags/工作效率/"}]},{"title":"Linux常用命令系列 - echo命令","slug":"linux_cat","date":"2017-08-26T08:36:36.000Z","updated":"2017-12-14T13:09:26.000Z","comments":true,"path":"linux_cat/","link":"","permalink":"http://tinyxiong.com/linux_cat/","excerpt":"echo 是Linux 下最常用的命令之一，用于终端打印。","text":"echo 是Linux 下最常用的命令之一，用于终端打印。 常用用法12$ echo \"Hello Bash\" Hello Bash 小技巧： 使用转义字符 12$ echo -e \"Hello\\tBash\"Hello Bash 使用转义字符打印彩色输出，如红色打印 12$ echo -e \"\\e[1;31m Hello Bash \\e[0m\"Hello Bash \\e[1;31m 表示将颜色设置为红色 颜色编号： 30 (黑色)、31 (红色)、32 (绿色)、33 (黄色)、34 (蓝色)、35 ( 紫红色)、36 (青色)和37 (白色) \\e[0m 表示将颜色重新置回 如果要进行格式化打印可以使用printf， 如：12$ printf \"%-10s %-10s %-4.2f\\n\" Hello Bash 88.8888Hello Bash 88.89 printf更多用户用法，有兴趣的可以参考。 使用截图： 原始链接:http://tinyxiong.com/ls/关于作者：Tiny熊：深入浅出区块链博主","categories":[{"name":"Linux","slug":"Linux","permalink":"http://tinyxiong.com/categories/Linux/"},{"name":"命令","slug":"Linux/命令","permalink":"http://tinyxiong.com/categories/Linux/命令/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://tinyxiong.com/tags/Linux/"},{"name":"命令","slug":"命令","permalink":"http://tinyxiong.com/tags/命令/"},{"name":"echo","slug":"echo","permalink":"http://tinyxiong.com/tags/echo/"}]},{"title":"Linux常用命令系列 - ls命令","slug":"linux_ls","date":"2017-08-20T08:36:36.000Z","updated":"2017-12-14T14:55:33.000Z","comments":true,"path":"linux_ls/","link":"","permalink":"http://tinyxiong.com/linux_ls/","excerpt":"ls 是Linux 下最常用的命令之一，用于列出文件和目录。","text":"ls 是Linux 下最常用的命令之一，用于列出文件和目录。 常用用法常用参数 -l(l : list) ： 显示文件（夹）内容详情 每行是一个文件的详情1234$ ls -ldrwxr-xr-x 6 Emmett staff 204 9 4 17:18 man-rw-r--r-- 1 Emmett staff 0 12 4 22:52 test_lastestlrwxr-xr-x 1 Emmett staff 13 12 4 22:58 p_readme -&gt; ../readme.txt 每个文件的详情分别用7列来表示第1列 第一个字母 表示文件类型 d 表示目录 - 表示文件 l 表示链接剩下的9个字母表示文件权限， 以三个字母为一组（rwx），分别表示 拥有者 所有组 其他人的权限第2列 表示多少链接指向这个文件第3列 表示文件/文件夹的所有者第4列 表示文件/文件夹的所有组第5列 表示文件/文件夹大小，以字节为单位第6列 表示文件最后的修改时间第7列 表示文件名或目录名 常用参数 -lh (h : human) 易于人类阅读的文件大小:12$ ls -lh-rw-r--r--@ 1 Emmett staff 960M 12 4 23:13 G718CH.zip 常用参数 -a (a: all) 显示所有文件（用于显示隐藏文件）参数：-S (S : Size )以文件大小排序参数： -t （t: time） 修改时间排序，新的文件在前参数：-r (r: reverse) 反转顺序 组合用法想一想， 如何查看最大的5个文件？1$ ls -S | head -5 用法截图 原始链接:http://tinyxiong.com/linux_ls/关于作者：Tiny熊：深入浅出区块链博主","categories":[{"name":"Linux","slug":"Linux","permalink":"http://tinyxiong.com/categories/Linux/"},{"name":"命令","slug":"Linux/命令","permalink":"http://tinyxiong.com/categories/Linux/命令/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://tinyxiong.com/tags/Linux/"},{"name":"命令","slug":"命令","permalink":"http://tinyxiong.com/tags/命令/"}]},{"title":"Linux常用命令列表 - 速查手册","slug":"linux_common_cmds","date":"2017-08-01T08:36:36.000Z","updated":"2017-12-09T14:39:22.000Z","comments":true,"path":"linux_common_cmds/","link":"","permalink":"http://tinyxiong.com/linux_common_cmds/","excerpt":"本文整理了Linux最常用一些命令，方便大家速查","text":"本文整理了Linux最常用一些命令，方便大家速查 常用命令 命令 说明 ls 列出目录 ls -al 使用格式化列出隐藏文件 cd dir 进入目录dir cd 进入 home 目录 pwd 显示当前目录 mkdir dir 创建目录 dir rm file 删除文件 file rm -r dir 删除目录 dir rm -f file 强制删除 file rm -rf dir 强制删除目录 dir cp file1 file2 将 file1 复制到 file2 cp -r dir1 dir2 将 dir1 复制到 dir2; 如果 dir2 不存在则创建它 mv file1 file2 将 file1 重命名或移动到 file2; 如果file2 是已存在目录则将 file1 移动到目录 file2 中 ln -s file link 创建 file 的符号连接 link touch file 创建名file的文件 cat &gt; file 将标准输入添加到 file more file 查看 file 的内容 tail -f file 从后 10 行开始查看 file 的内容 man command 显示 command 的说明手册 ps 显示当前的活动进程 top 显示所有正在运行的进程 kill pid 杀掉进程 id pid killall proc 杀掉所有名为 proc 的进程 chmod octal file 更改 file 的权限 grep pattern files 搜索 files 中匹配 pattern 的内容 df 显示磁盘占用情况 du 显示目录空间占用情况 tar xzf file.tar.gz 使用 Gzip 解压 tar 文件 tar xjf file.tar.bz2 使用 Bzip2 解压 tar 文件 ping host ping host 并输出结果 wget file 下载 file 原始链接:http://tinyxiong.com/linux_common_cmds/关于作者：Tiny熊：深入浅出区块链博主","categories":[{"name":"Linux","slug":"Linux","permalink":"http://tinyxiong.com/categories/Linux/"},{"name":"命令","slug":"Linux/命令","permalink":"http://tinyxiong.com/categories/Linux/命令/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://tinyxiong.com/tags/Linux/"},{"name":"命令","slug":"命令","permalink":"http://tinyxiong.com/tags/命令/"},{"name":"速查手册","slug":"速查手册","permalink":"http://tinyxiong.com/tags/速查手册/"}]}]}